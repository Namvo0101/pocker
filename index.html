<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  :root{
    --bg: #f6f7fb;
    --card: #ffffff;
    --line: rgba(0,0,0,0.12);
    --line-strong: rgba(0,0,0,0.22);
    --text: #111827;
    --muted: #6b7280;

    --ok-bg: rgba(16,185,129,0.08);
    --err-bg: rgba(239,68,68,0.08);

    --shadow: 0 10px 30px rgba(0,0,0,0.08);
    --shadow-sm: 0 6px 16px rgba(0,0,0,0.10);
    --radius: 16px;

    --check-col: 44px;
    --topbar-pad: 10px;

    --chip-bg: #f3f4f6;
    --chip-border: rgba(0,0,0,0.16);
    --chip-fixed: #6d28d9;
  }

  * , *::before, *::after { box-sizing: border-box; }
  html, body{
    width: 100%;
    max-width: 100%;
    margin: 0;
    padding: 0;
    overflow-x: clip;
  }
  @supports not (overflow: clip){
    html, body{ overflow-x: hidden; }
  }

  body{
    text-align: center;
    background: var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  /* ===== Fixed Topbar ===== */
  .topbar{
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 999;
    background: var(--bg);
    padding: var(--topbar-pad) 10px 10px;
    border-bottom: 1px solid var(--line);
  }

  .topbar-inner{
    max-width: 980px;
    margin: 0 auto;
  }

  #header{
    font-size: 12px;
    margin: 0 auto 8px;
    color: var(--muted);
    letter-spacing: 0.12em;
  }

  .namebar-card{
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow-sm);
    padding: 8px;
    overflow: visible;
  }

  .namebar-scroll{
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-x: contain;
  }

  /* ✅ Grid thẳng hàng với bảng: check + 4 cột */
  .namegrid{
    display: grid;
    grid-template-columns: var(--check-col) repeat(4, 1fr);
    gap: 8px;
    align-items: stretch;           /* ✅ các ô tự stretch cùng chiều cao */
    width: 100%;
    min-width: 0;
  }

  .namegrid .spacer{
    width: 100%;
  }

  /* ✅ Ô tên: cho phép xuống dòng + chữ to hơn */
  .namechip{
    background: var(--chip-bg);
    border: 1px solid var(--chip-border);
    border-radius: 16px;
    padding: 8px 10px;
    width: 100%;
    height: 100%;                  /* ✅ bằng nhau về chiều cao */
    min-height: 44px;              /* ✅ tối thiểu đẹp */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;

    /* ✅ cho phép wrap */
    white-space: normal;
    overflow: visible;
    word-break: break-word;
    line-height: 1.15;

    font-size: clamp(14px, 3.2vw, 20px); /* ✅ to hơn */
    font-family: inherit;
  }

  /* input tên vẫn 1 dòng khi đang sửa (bình thường) */
  .namechip input[type="text"]{
    width: 100%;
    border: none;
    outline: none;
    background: transparent;
    text-align: center;
    font-size: inherit;
    padding: 0;
    font-family: inherit;
  }

  /* ✅ Khi fix tên: đậm + tím + cho phép wrap */
  .name-fixed{
    font-weight: 800;
    color: var(--chip-fixed);
    display: block;
    width: 100%;
    text-align: center;
    font-family: inherit;

    white-space: normal;
    word-break: break-word;
    line-height: 1.15;
  }

  /* Wrap content */
  .wrap{
    max-width: 980px;
    width: 100%;
    margin: 0 auto;
    padding: 0 10px 26px;
  }

  .spacer-top{ height: 140px; } /* JS auto set */

  .table-card{
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 10px;
    width: 100%;
    overflow: hidden;
  }

  .table-scroll{
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-x: contain;
  }

  table{
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    min-width: 0;
    background: var(--card);
  }

  th, td{
    padding: 10px 8px;
    text-align: center;
    border-bottom: 1px solid var(--line);
    vertical-align: middle;
  }

  thead th{
    background: #f3f4f6;
    border-bottom: 1px solid var(--line-strong);
    font-size: 14px;
    color: var(--muted);
  }

  #scoreTable th:first-child,
  #scoreTable td:first-child{
    width: var(--check-col);
    min-width: var(--check-col);
    max-width: var(--check-col);
    padding-left: 6px;
    padding-right: 6px;
  }

  tbody tr:nth-child(even){ background: rgba(0,0,0,0.02); }
  tbody tr.row-ok{ background: linear-gradient(0deg, var(--ok-bg), var(--ok-bg)); }
  tbody tr.row-error{ background: linear-gradient(0deg, var(--err-bg), var(--err-bg)); }

  input[type="number"]{
    width: 100%;
    max-width: none;
    padding: 8px 10px;
    border-radius: 12px;
    border: 1px solid var(--line);
    outline: none;
    background: #fff;
    text-align: center;
    font-size: 18px;
    transition: box-shadow .15s ease, border-color .15s ease;
    font-family: inherit;
  }
  input[type="number"]:focus{
    border-color: rgba(59,130,246,0.55);
    box-shadow: 0 0 0 4px rgba(59,130,246,0.18);
  }

  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral  { color: grey; }

  .check-positive, .check-negative{
    display: inline-block;
    width: 1.2em;
    text-align: center;
    font-weight: 800;
    line-height: 1;
    font-size: 22px;
  }
  .check-positive { color: green; }
  .check-negative { color: red; }

  .controls{
    margin: 14px auto 0;
    display: grid;
    gap: 10px;
    justify-content: center;
  }
  .controls-row{
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  button{
    margin-top: 0;
    font-size: 26px;
    padding: 12px 18px;
    border-radius: 16px;
    border: 1px solid var(--line);
    background: #fff;
    box-shadow: var(--shadow-sm);
    cursor: pointer;
    transition: transform .05s ease, box-shadow .15s ease, filter .15s ease;
    user-select: none;
    font-family: inherit;
  }
  button:active{ transform: translateY(1px); }
  button:hover{ filter: brightness(0.99); }

  .btn-primary{ background: #111827; color: #fff; border-color: rgba(17,24,39,0.35); }
  .btn-secondary{ background: #fff; color: #111827; }
  .btn-danger{ background: rgba(239,68,68,0.10); border-color: rgba(239,68,68,0.35); color: #991b1b; }
  .btn-success{ background: rgba(16,185,129,0.12); border-color: rgba(16,185,129,0.35); color: #065f46; }

  @media (max-width: 600px){
    :root{ --check-col: 36px; }
    input[type="number"]{ font-size: 16px; padding: 7px 8px; }
    button { font-size: 22px; padding: 10px 14px; border-radius: 14px; box-shadow: none; }
    .table-card{ box-shadow: none; }
    .namebar-card{ box-shadow: none; }
    .check-positive, .check-negative{ font-size: 20px; }
    .namegrid{ gap: 6px; }
    .namechip{ padding: 7px 8px; min-height: 40px; font-size: clamp(13px, 3.4vw, 18px); }
  }
</style>
</head>
<body>

<div class="topbar" id="topbar">
  <div class="topbar-inner">
    <div id="header">------ Nam Vo ------</div>

    <div class="namebar-card">
      <div class="namebar-scroll">
        <div class="namegrid">
          <div class="spacer"></div>

          <div class="namechip" id="namecell-0">
            <input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)">
          </div>
          <div class="namechip" id="namecell-1">
            <input type="text" id="name-1" value="Phương Nam" onblur="setName(1)">
          </div>
          <div class="namechip" id="namecell-2">
            <input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)">
          </div>
          <div class="namechip" id="namecell-3">
            <input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)">
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<div class="wrap">
  <div class="spacer-top" id="spacerTop"></div>

  <div class="table-card">
    <div class="table-scroll">
      <table id="scoreTable">
        <thead>
          <tr>
            <th></th>
            <th></th><th></th><th></th><th></th>
          </tr>
          <tr style="display:none;">
            <td></td>
            <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="controls">
    <div class="controls-row">
      <button class="btn-secondary" onclick="enterPoints()">Enter Points</button>
      <button class="btn-primary" onclick="completeScores()">Complete</button>
    </div>
    <div class="controls-row">
      <button class="btn-danger" onclick="resetGame()">Reset</button>
      <button class="btn-success" onclick="exportPDF()">Export PDF</button>
    </div>
  </div>
</div>

<script src="./libs/jspdf.umd.min.js"></script>
<script src="./libs/jspdf.plugin.autotable.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";
  var __isResetting = false;

  var MASTER_PASSWORD = "vophuongnam";
  var PASSWORD_KEY = STORAGE_KEY + "_pwd";

  function isNewGame() { return !localStorage.getItem(STORAGE_KEY); }

  function initPasswordIfNewGame() {
    if (!isNewGame()) return;
    if (localStorage.getItem(PASSWORD_KEY)) return;

    var pwd = prompt("Khởi tạo mật khẩu cho ván chơi.");
    if (pwd === null) return;

    pwd = String(pwd).trim();
    if (!pwd) { alert("Mật khẩu không được để trống."); return; }
    localStorage.setItem(PASSWORD_KEY, pwd);
  }

  function requirePasswordForExport() {
    var entered = prompt("Nhập mật khẩu để xuất PDF.");
    if (entered === null) return false;

    entered = String(entered).trim();
    var gamePwd = localStorage.getItem(PASSWORD_KEY) || "";

    if (entered === gamePwd || entered === MASTER_PASSWORD) return true;
    alert("Mật khẩu sai.");
    return false;
  }

  function syncTopSpacer() {
    var topbar = document.getElementById("topbar");
    var spacer = document.getElementById("spacerTop");
    spacer.style.height = (topbar.offsetHeight + 12) + "px";
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function applySignColorToInput(input) {
    input.classList.remove("score-positive", "score-negative", "score-neutral");
    var raw = (input.value || "").trim();
    var n = parseInt(raw, 10);

    if (raw === "" || isNaN(n) || n === 0) input.classList.add("score-neutral");
    else if (n > 0) input.classList.add("score-positive");
    else input.classList.add("score-negative");
  }

  function bindScoreInput(input) {
    if (input.dataset && input.dataset.bound === "1") {
      applySignColorToInput(input);
      return;
    }
    if (input.dataset) input.dataset.bound = "1";

    applySignColorToInput(input);

    input.addEventListener("input", function() {
      applySignColorToInput(input);
      saveGame();
    });
  }

  function applyColorsToAllScoreInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) { applySignColorToInput(inp); });
    }
  }

  function saveGame() {
    if (__isResetting) return;

    var table = document.getElementById("scoreTable");
    var data = { headers: [], rows: [] };

    for (var i = 0; i < 4; i++) {
      var cell = document.getElementById("namecell-" + i);
      var input = cell ? cell.querySelector("input") : null;
      if (input) data.headers.push({ isInput: true, value: input.value });
      else data.headers.push({ isInput: false, value: cell ? cell.innerHTML : "" });
    }

    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var rowObj = { check: row.cells[0].innerHTML, scores: [] };
      for (var c = 1; c <= 4; c++) {
        var cellInput = row.cells[c].firstChild;
        rowObj.scores.push(cellInput ? (cellInput.value || "") : "");
      }
      data.rows.push(rowObj);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function loadGame() {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var trimmed = String(raw).trim();
    if (trimmed[0] !== "{") return;

    try {
      var data = JSON.parse(trimmed);
      if (!(data && data.headers && data.rows)) return;

      for (var i = 0; i < 4; i++) {
        var wrap = document.getElementById("namecell-" + i);
        var h = data.headers[i];

        if (wrap && h && h.isInput) {
          wrap.innerHTML = '<input type="text" id="name-' + i + '" value="' + escapeHtml(h.value || "") + '" onblur="setName(' + i + ')">';
        } else if (wrap) {
          wrap.innerHTML = (h && h.value != null) ? h.value : wrap.innerHTML;
        }
      }

      var table = document.getElementById("scoreTable");
      while (table.rows.length > 2) table.deleteRow(-1);

      if (data.rows && data.rows.length) {
        data.rows.forEach(function(r) {
          var row = table.insertRow(-1);
          var checkCell = row.insertCell(0);
          checkCell.innerHTML = r.check || '';

          for (var i = 1; i <= 4; i++) {
            var cell = row.insertCell(i);
            cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
            var inp = cell.firstChild;
            inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
            bindScoreInput(inp);
          }
        });
      }

      completeScores();
    } catch (e) {}
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var wrap = document.getElementById("namecell-" + index);

    wrap.innerHTML = '<span class="name-fixed">' + escapeHtml(name) + '</span>';

    saveGame();
    syncTopSpacer();
  }

  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    __isResetting = true;

    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(PASSWORD_KEY);

    setTimeout(function(){ location.reload(); }, 0);
  }

  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0);
    checkCell.innerHTML = '';
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      bindScoreInput(cell.firstChild);
    }
    saveGame();
  }

  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    applyColorsToAllScoreInputs();

    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) totalElement.className = 'score-positive total-score';
      else if (totals[i] < 0) totalElement.className = 'score-negative total-score';
      else totalElement.className = 'score-neutral total-score';
    }

    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) {
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }

      row.classList.remove("row-ok", "row-error");

      var checkCell = row.cells[0];
      if (rowSum === 0) {
        checkCell.innerHTML = '<span class="check-positive">O</span>';
        row.classList.add("row-ok");
      } else {
        checkCell.innerHTML = '<span class="check-negative">X</span>';
        row.classList.add("row-error");
        error = true;
      }
    }

    saveGame();
    if (error) alert("Nhập sai rồi bạn êyyyy ^_^");
  }

  /* ===== PDF (giữ nguyên logic) ===== */
  let __pdfFontCache = null;

  function __arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }

  async function __getPdfFontCache() {
    if (__pdfFontCache) return __pdfFontCache;

    const regularUrl = "./fonts/NotoSans-Regular.ttf";
    const boldUrl = "./fonts/NotoSans-Bold.ttf";

    const [regBuf, boldBuf] = await Promise.all([
      fetch(regularUrl).then(r => { if (!r.ok) throw new Error(); return r.arrayBuffer(); }),
      fetch(boldUrl).then(r => { if (!r.ok) throw new Error(); return r.arrayBuffer(); })
    ]);

    __pdfFontCache = {
      regularB64: __arrayBufferToBase64(regBuf),
      boldB64: __arrayBufferToBase64(boldBuf)
    };
    return __pdfFontCache;
  }

  async function __attachVietnameseFontsToDoc(doc) {
    const cache = await __getPdfFontCache();
    doc.addFileToVFS("NotoSans-Regular.ttf", cache.regularB64);
    doc.addFont("NotoSans-Regular.ttf", "NotoSans", "normal");
    doc.addFileToVFS("NotoSans-Bold.ttf", cache.boldB64);
    doc.addFont("NotoSans-Bold.ttf", "NotoSans", "bold");
  }

  async function doExportPDF() {
    completeScores();
    if (!window.jspdf || !window.jspdf.jsPDF) return;

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });
    await __attachVietnameseFontsToDoc(doc);

    function getPlayerName(i) {
      var cell = document.getElementById("namecell-" + i);
      if (!cell) return "";
      var inp = cell.querySelector("input");
      var v = inp ? inp.value : (cell.textContent || "");
      return String(v || "").trim();
    }
    const names = [0,1,2,3].map(getPlayerName);

    doc.setFont("NotoSans", "bold");
    doc.setFontSize(16);
    doc.text("—— Nam Vo ——", doc.internal.pageSize.getWidth() / 2, 50, { align: "center" });

    const head = [["#", "", names[0], names[1], names[2], names[3]]];
    const totals = [0,1,2,3].map(i => document.getElementById("total-score-" + i).innerText);

    const body = [];
    body.push(["", "TOTAL", totals[0], totals[1], totals[2], totals[3]]);

    const table = document.getElementById("scoreTable");
    let round = 0;
    for (let r = 2; r < table.rows.length; r++) {
      round += 1;
      const row = table.rows[r];
      const check = (row.cells[0].textContent || "").trim();
      const vals = [];
      for (let c = 1; c <= 4; c++) vals.push(String(parseInt(row.cells[c].firstChild.value) || 0));
      body.push([String(round), check, vals[0], vals[1], vals[2], vals[3]]);
    }

    function signColor(n) {
      if (n > 0) return [0, 128, 0];
      if (n < 0) return [204, 0, 0];
      return [128, 128, 128];
    }

    doc.autoTable({
      startY: 80,
      head,
      body,
      theme: "grid",
      styles: { font: "NotoSans", fontStyle: "normal", halign: "center", valign: "middle", fontSize: 11, cellPadding: 6 },
      headStyles: { font: "NotoSans", fontStyle: "bold", fillColor: [237, 237, 237], textColor: 0 },
      alternateRowStyles: { fillColor: [251, 251, 251] },
      columnStyles: { 0: { cellWidth: 26 }, 1: { cellWidth: 48 } },
      didParseCell: function (data) {
        const row = data.row, col = data.column, cell = data.cell;

        if (data.section === "body" && row.index === 0) {
          cell.styles.fontStyle = "bold";
          cell.styles.fillColor = [247, 247, 247];
          if (col.index >= 2) cell.styles.textColor = signColor(parseInt(cell.raw, 10) || 0);
        }

        if (data.section === "body" && row.index >= 1 && col.index >= 2) {
          cell.styles.textColor = signColor(parseInt(cell.raw, 10) || 0);
        }

        if (data.section === "body" && col.index === 1) {
          const v = String(cell.raw || "").trim();
          cell.styles.fontStyle = "bold";
          if (v === "O") cell.styles.textColor = [0,128,0];
          else if (v === "X") cell.styles.textColor = [204,0,0];
        }

        if (data.section === "body" && col.index === 0) {
          cell.styles.textColor = [128,128,128];
        }
      }
    });

    const now = new Date();
    const pad2 = (n) => String(n).padStart(2, "0");
    const stamp =
      "Report được tạo vào ngày " +
      pad2(now.getDate()) + "/" + pad2(now.getMonth() + 1) + "/" + now.getFullYear() + " " +
      pad2(now.getHours()) + ":" + pad2(now.getMinutes()) + ":" + pad2(now.getSeconds()) +
      " bởi Nam Võ";

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    let y = (doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 80) + 28;
    if (y > pageH - 40) { doc.addPage(); y = 50; }

    doc.setFont("NotoSans", "normal");
    doc.setFontSize(10);
    doc.text(stamp, pageW - 40, y, { align: "right" });

    const filename =
      "scores_" +
      now.getFullYear() + "-" + pad2(now.getMonth() + 1) + "-" + pad2(now.getDate()) + "_" +
      pad2(now.getHours()) + pad2(now.getMinutes()) +
      ".pdf";

    doc.save(filename);
  }

  async function exportPDF() {
    if (!requirePasswordForExport()) return;
    await doExportPDF();
  }

  window.addEventListener("load", function() {
    loadGame();
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) { bindScoreInput(inp); });
    }
    initPasswordIfNewGame();
    syncTopSpacer();
  });

  window.addEventListener("resize", function() { syncTopSpacer(); });

  window.addEventListener("beforeunload", function() {
    if (!__isResetting) saveGame();
  });
</script>

</body>
</html>
