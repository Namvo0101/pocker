<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  body { 
    text-align: center; 
    margin: 0; 
    padding: 0; 
  }
  #header {
    font-size: 10px;
    margin-top: 5px; 
    margin-bottom: 5px;
  }
  table { 
    margin: auto; 
    border: 1px solid black; 
    border-collapse: collapse; 
    width: 90%;
  }
  th, td { 
    padding: 5px; 
    text-align: center; 
    box-sizing: border-box;
    word-wrap: break-word;
  }
  th { background-color: #f2f2f2; }

  input[type="number"], input[type="text"] { 
    width: 20%;
    box-sizing: border-box;
    text-align: center;
  }

  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral  { color: grey; }

  .check-positive { color: green; }
  .check-negative { color: red; }
  .total-score { font-size: 24px; font-weight: bold; }

  button {
    margin-top: 10px;
    font-size: 30px;
    padding: 10px 20px;
  }

  @media (max-width: 600px) {
    .total-score { font-size: 18px; }
    button { font-size: 30px; padding: 8px 16px; }
    th, td { padding: 3px; }
  }

  /* sticky header */
  #scoreTable thead, #scoreTable thead th {
    position: sticky;
    top: 0;
    background-color: #f2f2f2;
    z-index: 10;
    font-size: 30px;
  }

  /* Ẩn dòng Total trên web */
  #scoreTable thead tr:nth-child(2) {
    display: none;
  }
</style>
</head>
<body>

<div id="header">------ Nam Vo ------</div>

<table id="scoreTable">
  <thead>
    <tr>
      <th></th>
      <th><input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)"></th>
      <th><input type="text" id="name-1" value="Phương Nam" onblur="setName(1)"></th>
      <th><input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)"></th>
      <th><input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)"></th>
    </tr>

    <!-- vẫn giữ trong DOM để tính total/export, chỉ ẩn bằng CSS -->
    <tr>
      <td></td>
      <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<button onclick="enterPoints()">Enter Points</button>
<button onclick="completeScores()">Complete</button>
<button onclick="resetGame()">Reset</button>
<br>
<button onclick="exportPDF()">Export PDF</button>

<!-- PDF libs (local) -->
<script src="./libs/jspdf.umd.min.js"></script>
<script src="./libs/jspdf.plugin.autotable.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";

  /* ================== version_5: live sign color for each input ================== */
  function applySignColorToInput(input) {
    input.classList.remove("score-positive", "score-negative", "score-neutral");

    var raw = (input.value || "").trim();
    var n = parseInt(raw, 10);

    if (raw === "" || isNaN(n) || n === 0) input.classList.add("score-neutral");
    else if (n > 0) input.classList.add("score-positive");
    else input.classList.add("score-negative");
  }

  function bindScoreInput(input) {
    if (input.dataset && input.dataset.bound === "1") {
      applySignColorToInput(input);
      return;
    }
    if (input.dataset) input.dataset.bound = "1";

    applySignColorToInput(input);

    input.addEventListener("input", function() {
      applySignColorToInput(input);
      saveGame();
    });
  }

  function applyColorsToAllScoreInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) {
        applySignColorToInput(inp);
      });
    }
  }

  /* ==================== SAVE/LOAD ==================== */
  function saveGame() {
    var table = document.getElementById("scoreTable");
    var data = { headers: [], rows: [] };

    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var input = th.querySelector("input");
      if (input) data.headers.push({ isInput: true, value: input.value });
      else data.headers.push({ isInput: false, value: th.innerHTML });
    }

    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var rowObj = { check: row.cells[0].innerHTML, scores: [] };
      for (var c = 1; c <= 4; c++) {
        var cellInput = row.cells[c].firstChild;
        rowObj.scores.push(cellInput ? (cellInput.value || "") : "");
      }
      data.rows.push(rowObj);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function attachAutoSaveToExistingInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) {
        bindScoreInput(inp);
      });
    }
  }

  function loadGame() {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var table = document.getElementById("scoreTable");
    var trimmed = String(raw).trim();

    // JSON format
    if (trimmed[0] === "{") {
      try {
        var data = JSON.parse(trimmed);
        if (data && data.headers && data.rows) {
          for (var i = 0; i < 4; i++) {
            var th = table.rows[0].cells[i + 1];
            var h = data.headers[i];
            if (h && h.isInput) {
              th.innerHTML = '<input type="text" id="name-' + i + '" value="' + (h.value || "") + '" onblur="setName(' + i + ')">';
            } else {
              th.innerHTML = (h && h.value != null) ? h.value : th.innerHTML;
            }
          }

          while (table.rows.length > 2) table.deleteRow(-1);

          if (data.rows && data.rows.length) {
            data.rows.forEach(function(r) {
              var row = table.insertRow(-1);
              var checkCell = row.insertCell(0);
              checkCell.innerHTML = r.check || '';

              for (var i = 1; i <= 4; i++) {
                var cell = row.insertCell(i);
                cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
                var inp = cell.firstChild;
                inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
                bindScoreInput(inp);
              }
            });
          }

          completeScores();
          return;
        }
      } catch (e) {}
    }

    // HTML fallback
    if (trimmed[0] === "<" && trimmed.toLowerCase().indexOf("<table") !== -1) {
      try {
        var wrapper = document.createElement("div");
        wrapper.innerHTML = trimmed;
        var newTable = wrapper.querySelector("table");
        if (newTable && newTable.id === "scoreTable") {
          table.replaceWith(newTable);
          attachAutoSaveToExistingInputs();
          completeScores();
          saveGame();
          return;
        }
      } catch (e2) {}
    }

    localStorage.removeItem(STORAGE_KEY);
  }

  /* ==================== CORE ==================== */
  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var th = input.parentElement;
    th.innerHTML = name;
    saveGame();
  }

  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0);
    checkCell.innerHTML = '';
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      bindScoreInput(cell.firstChild);
    }
    saveGame();
  }

  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    // keep input colors in sync
    applyColorsToAllScoreInputs();

    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) totalElement.className = 'score-positive total-score';
      else if (totals[i] < 0) totalElement.className = 'score-negative total-score';
      else totalElement.className = 'score-neutral total-score';
    }

    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) {
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }
      var checkCell = row.cells[0];
      if (rowSum === 0) checkCell.innerHTML = '<span class="check-positive">O</span>';
      else { checkCell.innerHTML = '<span class="check-negative">X</span>'; error = true; }
    }

    saveGame();
    if (error) alert("Nhập sai rồi bạn êyyyy ^_^");
  }

  /* ==================== PDF FONT LOADER (attach to doc instance) ==================== */
  let __pdfFontCache = null; // { regularB64, boldB64 }

  function __arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }

  async function __getPdfFontCache() {
    if (__pdfFontCache) return __pdfFontCache;

    const regularUrl = "./fonts/NotoSans-Regular.ttf";
    const boldUrl = "./fonts/NotoSans-Bold.ttf";

    const [regBuf, boldBuf] = await Promise.all([
      fetch(regularUrl).then(r => {
        if (!r.ok) throw new Error("Không tải được font: " + regularUrl);
        return r.arrayBuffer();
      }),
      fetch(boldUrl).then(r => {
        if (!r.ok) throw new Error("Không tải được font: " + boldUrl);
        return r.arrayBuffer();
      })
    ]);

    __pdfFontCache = {
      regularB64: __arrayBufferToBase64(regBuf),
      boldB64: __arrayBufferToBase64(boldBuf)
    };
    return __pdfFontCache;
  }

  async function __attachVietnameseFontsToDoc(doc) {
    const cache = await __getPdfFontCache();

    doc.addFileToVFS("NotoSans-Regular.ttf", cache.regularB64);
    doc.addFont("NotoSans-Regular.ttf", "NotoSans", "normal");

    doc.addFileToVFS("NotoSans-Bold.ttf", cache.boldB64);
    doc.addFont("NotoSans-Bold.ttf", "NotoSans", "bold");
  }

  /* ==================== EXPORT PDF (UPDATED timestamp placement) ==================== */
  async function exportPDF() {
    completeScores();

    if (!window.jspdf || !window.jspdf.jsPDF) {
      alert("Chưa load được thư viện jsPDF.\nHãy kiểm tra:\n/libs/jspdf.umd.min.js\n/libs/jspdf.plugin.autotable.min.js");
      return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });

    try {
      await __attachVietnameseFontsToDoc(doc);
    } catch (e) {
      alert("Lỗi load font PDF: " + (e && e.message ? e.message : e));
      return;
    }

    const table = document.getElementById("scoreTable");

    function getPlayerName(i) {
      const cell = table.rows[0] && table.rows[0].cells[i + 1];
      if (!cell) return "";
      const inp = cell.querySelector("input");
      const v = inp ? inp.value : (cell.textContent || "");
      return String(v || "").trim();
    }

    const names = [0, 1, 2, 3].map(getPlayerName);

    // Header
    doc.setFont("NotoSans", "bold");
    doc.setFontSize(16);
    doc.text("—— Nam Vo ——", doc.internal.pageSize.getWidth() / 2, 50, { align: "center" });

    // Table: 5 columns (check + 4 players)
    const head = [["", names[0], names[1], names[2], names[3]]];

    const totals = [0, 1, 2, 3].map(i => document.getElementById("total-score-" + i).innerText);

    const body = [];
    body.push(["TOTAL", totals[0], totals[1], totals[2], totals[3]]);

    for (let r = 2; r < table.rows.length; r++) {
      const row = table.rows[r];
      const check = (row.cells[0].textContent || "").trim();
      const vals = [];
      for (let c = 1; c <= 4; c++) vals.push(String(parseInt(row.cells[c].firstChild.value) || 0));
      body.push([check, vals[0], vals[1], vals[2], vals[3]]);
    }

    function signColor(n) {
      if (n > 0) return [0, 128, 0];
      if (n < 0) return [204, 0, 0];
      return [128, 128, 128];
    }

    doc.autoTable({
      startY: 80,
      head,
      body,
      theme: "grid",
      styles: {
        font: "NotoSans",
        fontStyle: "normal",
        halign: "center",
        valign: "middle",
        fontSize: 11,
        cellPadding: 6
      },
      headStyles: {
        font: "NotoSans",
        fontStyle: "bold",
        fillColor: [237, 237, 237],
        textColor: 0
      },
      alternateRowStyles: { fillColor: [251, 251, 251] },
      didParseCell: function (data) {
        const row = data.row;
        const col = data.column;
        const cell = data.cell;

        // TOTAL row (body row 0)
        if (data.section === "body" && row.index === 0) {
          cell.styles.font = "NotoSans";
          cell.styles.fontStyle = "bold";
          cell.styles.fillColor = [247, 247, 247];
          if (col.index >= 1) {
            const n = parseInt(cell.raw, 10) || 0;
            cell.styles.textColor = signColor(n);
          } else {
            cell.styles.textColor = 0;
          }
        }

        // Data rows: color by sign
        if (data.section === "body" && row.index >= 1 && col.index >= 1) {
          const n = parseInt(cell.raw, 10) || 0;
          cell.styles.textColor = signColor(n);
        }

        // Check column O/X
        if (data.section === "body" && col.index === 0) {
          const v = String(cell.raw || "").trim();
          cell.styles.font = "NotoSans";
          cell.styles.fontStyle = "bold";
          if (v === "O") cell.styles.textColor = [0, 128, 0];
          else if (v === "X") cell.styles.textColor = [204, 0, 0];
          else cell.styles.textColor = [128, 128, 128];
        }
      }
    });

    // Timestamp: đặt ngay sau bảng, cách 2 dòng, căn phải + thêm "bởi Nam Võ"
    const now = new Date();
    const pad2 = (n) => String(n).padStart(2, "0");
    const stamp =
      "Report được tạo vào ngày " +
      pad2(now.getDate()) + "/" + pad2(now.getMonth() + 1) + "/" + now.getFullYear() + " " +
      pad2(now.getHours()) + ":" + pad2(now.getMinutes()) + ":" + pad2(now.getSeconds()) +
      " bởi Nam Võ";

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    const rightMargin = 40;
    const topMargin = 50;

    // jsPDF-AutoTable exposes lastAutoTable.finalY
    const lastY = (doc.lastAutoTable && doc.lastAutoTable.finalY) ? doc.lastAutoTable.finalY : 80;

    // "cách bảng 2 dòng"
    const lineHeight = 14;
    let y = lastY + (2 * lineHeight);

    // nếu sắp vượt trang thì xuống trang mới
    if (y > pageH - 40) {
      doc.addPage();
      y = topMargin;
    }

    doc.setFont("NotoSans", "normal");
    doc.setFontSize(10);
    doc.text(stamp, pageW - rightMargin, y, { align: "right" });

    const filename =
      "scores_" +
      now.getFullYear() + "-" + pad2(now.getMonth() + 1) + "-" + pad2(now.getDate()) + "_" +
      pad2(now.getHours()) + pad2(now.getMinutes()) +
      ".pdf";

    doc.save(filename);
  }

  window.addEventListener("load", function() {
    loadGame();
    attachAutoSaveToExistingInputs();
  });

  window.addEventListener("beforeunload", saveGame);
</script>

</body>
</html>
